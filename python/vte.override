/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#include <Python.h>
#include <pygtk/pygtk.h>
#include <pygobject.h>
#include <gtk/gtk.h>
#include "../src/vte.h"
%%
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import gtk.MenuShell as PyGtkMenuShell_Type
import gtk.Widget as PyGtkWidget_Type
%%
override vte_terminal_fork_command kwargs

static PyObject *
_wrap_vte_terminal_fork_command(PyGObject * self, PyObject * args,
				PyObject * kwargs)
{
	gchar **argv = NULL, **envv = NULL;
	gchar *command = NULL, *directory = NULL;
	static char *kwlist[] = { "command", "argv", "envv", "directory",
				  "loglastlog", "logutmp", "logwtmp",
				  NULL };
	PyObject *py_argv = NULL, *py_envv = NULL,
		 *loglastlog = NULL, *logutmp = NULL, *logwtmp = NULL;
	int i, n_args, n_envs;
	pid_t pid;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|sOOsOOO:fork_command",
					 kwlist, &command, &py_argv, &py_envv,
					 &directory,
					 &loglastlog, &logutmp, &logwtmp)) {
		return NULL;
	}


	if (py_argv != NULL && py_argv != Py_None) {
		if (!PySequence_Check(py_argv)) {
			PyErr_SetString(PyExc_TypeError,
					"argv must be a sequence");
			return NULL;
		}

		n_args = PySequence_Length(py_argv);
		argv = g_new(gchar *, n_args + 1);
		for (i = 0; i < n_args; i++) {
			PyObject *item = PySequence_GetItem(py_argv, i);
			Py_DECREF(item);  /* PySequence_GetItem INCREF's */
			argv[i] = PyString_AsString(item);
		}
		argv[n_args] = NULL;
	}

	if (py_envv != NULL && py_envv != Py_None) {
		if (!PySequence_Check(py_envv)) {
			PyErr_SetString(PyExc_TypeError,
					"envv must be a sequence");
			return NULL;
		}

		n_envs = PySequence_Length(py_envv);
		envv = g_new(gchar *, n_envs + 1);
		for (i = 0; i < n_envs; i++) {
			PyObject *item = PySequence_GetItem(py_envv, i);
			Py_DECREF(item);  /* PySequence_GetItem INCREF's */
			envv[i] = PyString_AsString(item);
		}
		envv[n_envs] = NULL;
	}

	pid = vte_terminal_fork_command(VTE_TERMINAL(self->obj),
					command, argv, envv, directory,
					(loglastlog != NULL) &&
					PyObject_IsTrue(loglastlog),
					(logutmp != NULL) &&
					PyObject_IsTrue(logutmp),
					(logwtmp != NULL) &&
					PyObject_IsTrue(logwtmp));

	if (argv) {
		g_free(argv);
	}

	return PyInt_FromLong(pid);
}
%%
override vte_terminal_get_text kwargs

static gboolean
call_callback(VteTerminal *terminal, glong column, glong row, gpointer data)
{
    PyObject *cb, *self, *args, *result;
    gboolean ret;
    int i;
    if (!PyArg_ParseTuple(data, "|O:call_callback", &args)) {
        return FALSE;
    }
    args = PyList_New(0);
    cb = PySequence_GetItem(args, 0); /* INCREFs */
    Py_DECREF(cb);
    self = PySequence_GetItem(args, 1); /* INCREFs */
    Py_DECREF(self);
    PyList_Append(args, self);
    PyList_Append(args, PyInt_FromLong(column));
    PyList_Append(args, PyInt_FromLong(row));
    for (i = 2; i < PySequence_Length(args); i++) {
        PyObject *item = PySequence_GetItem(args, i);
	Py_DECREF(item);
        PyList_Append(args, item);
    }
    result = PyObject_CallObject(cb, args);
    ret = (result && PyObject_IsTrue(result));
    Py_DECREF(args);
    Py_DECREF(result);
    return ret;
}

static gboolean
always_true(VteTerminal *terminal, glong row, glong column, gpointer data)
{
    return TRUE;
}
static PyObject *
_wrap_vte_terminal_get_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "callback", "attributes", "data", NULL };
    PyObject *callback = NULL, *do_attr = NULL, *data = NULL;
    PyObject *callback_and_args = NULL;
    GArray *attrs = NULL;
    PyObject *text;
    PyObject *py_attrs;
    int count;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OOO:terminal_get_text",
				     kwlist, &callback, &do_attr, &args)) {
        return NULL;
    }

    if (do_attr != NULL && do_attr != Py_None) {
	attrs = g_array_new(FALSE, TRUE, sizeof(struct vte_char_attributes));
    } else {
    	attrs = NULL;
    }

    if ((callback != NULL) && (callback != Py_None)) {
	if (!PyCallable_Check(callback)) {
	    PyErr_SetString(PyExc_TypeError, "1st argument not callable.");
            if (attrs) {
                g_array_free(attrs, TRUE);
            }
	    return NULL;
	}
    } else {
    	callback = NULL;
    }

    if (callback != NULL) {
        callback_and_args = PyList_New(0);
        PyList_Append(callback_and_args, callback);
        PyList_Append(callback_and_args, (PyObject*) self);
        if (PyList_Check(data)) {
            for (count = 0; count < PyList_Size(data); count++) {
                PyList_Append(callback_and_args, PyList_GetItem(data, count));
            }
        } else {
            PyList_Append(callback_and_args, data);
        }
    }

    text = PyString_FromString(vte_terminal_get_text(VTE_TERMINAL(self->obj),
						     callback ?
						     call_callback :
						     always_true,
						     callback ?
						     callback_and_args :
						     NULL,
						     attrs));
    Py_XDECREF(callback_and_args);

    if (attrs) {
	py_attrs = PyTuple_New(attrs->len);
	for (count = 0; count < attrs->len; count++) {
	    struct vte_char_attributes *cht;
	    PyObject *py_char_attr;
	    PyObject *py_gdkcolor;

	    cht = &g_array_index(attrs, struct vte_char_attributes, count);
	    py_char_attr = PyDict_New();
	    PyDict_SetItemString(py_char_attr, "row", PyInt_FromLong(cht->row));
	    PyDict_SetItemString(py_char_attr, "column", PyInt_FromLong(cht->column));
	    
	    py_gdkcolor = pyg_boxed_new(GDK_TYPE_COLOR, &cht->fore, TRUE, TRUE);
	    PyDict_SetItemString(py_char_attr, "fore", py_gdkcolor);
	    py_gdkcolor = pyg_boxed_new(GDK_TYPE_COLOR, &cht->back, TRUE, TRUE);
	    PyDict_SetItemString(py_char_attr, "back", py_gdkcolor);
	    
	    PyDict_SetItemString(py_char_attr, "underline", 
		    PyInt_FromLong(cht->underline));
	    PyDict_SetItemString(py_char_attr, "strikethrough", 
		    PyInt_FromLong(cht->strikethrough));

	    PyTuple_SetItem(py_attrs, count, py_char_attr);
	}
	g_array_free(attrs, TRUE);
	return Py_BuildValue("(OO)", text, py_attrs);
    } else {
    	return Py_BuildValue("O", text);
    }
}
%%
override vte_terminal_get_text_range kwargs
static PyObject *
_wrap_vte_terminal_get_text_range(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "callback", "start_row", "start_col", "end_row",
			      "end_col", "attributes", "data", NULL };
    PyObject *callback = NULL, *do_attr = NULL, *data = NULL;
    glong start_row, start_col, end_row, end_col;
    PyObject *callback_and_args = NULL;
    GArray *attrs = NULL;
    PyObject *text;
    PyObject *py_attrs;
    int count;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|llllOOO:terminal_get_text",
				     kwlist,
				     &start_row, &start_col, &end_row, &end_col,
				     &callback, &do_attr, &args)) {
        return NULL;
    }

    if (do_attr != NULL && do_attr != Py_None) {
	attrs = g_array_new(FALSE, TRUE, sizeof(struct vte_char_attributes));
    } else {
    	attrs = NULL;
    }

    if ((callback != NULL) && (callback != Py_None)) {
	if (!PyCallable_Check(callback)) {
	    PyErr_SetString(PyExc_TypeError, "1st argument not callable.");
            if (attrs) {
                g_array_free(attrs, TRUE);
            }
	    return NULL;
	}
    } else {
    	callback = NULL;
    }

    if (callback != NULL) {
        callback_and_args = PyList_New(0);
        PyList_Append(callback_and_args, callback);
        PyList_Append(callback_and_args, (PyObject*) self);
        if (PyList_Check(data)) {
            for (count = 0; count < PyList_Size(data); count++) {
                PyList_Append(callback_and_args, PyList_GetItem(data, count));
            }
        } else {
            PyList_Append(callback_and_args, data);
        }
    }

    text = PyString_FromString(vte_terminal_get_text_range(VTE_TERMINAL(self->obj),
							   start_row, start_col,
							   end_row, end_col,
							   callback ?
							   call_callback :
							   always_true,
							   callback ?
							   callback_and_args :
							   NULL,
							   attrs));
    Py_XDECREF(callback_and_args);

    if (attrs) {
	py_attrs = PyTuple_New(attrs->len);
	for (count = 0; count < attrs->len; count++) {
	    struct vte_char_attributes *cht;
	    PyObject *py_char_attr;
	    PyObject *py_gdkcolor;

	    cht = &g_array_index(attrs, struct vte_char_attributes, count);
	    py_char_attr = PyDict_New();
	    PyDict_SetItemString(py_char_attr, "row", PyInt_FromLong(cht->row));
	    PyDict_SetItemString(py_char_attr, "column", PyInt_FromLong(cht->column));
	    
	    py_gdkcolor = pyg_boxed_new(GDK_TYPE_COLOR, &cht->fore, TRUE, TRUE);
	    PyDict_SetItemString(py_char_attr, "fore", py_gdkcolor);
	    py_gdkcolor = pyg_boxed_new(GDK_TYPE_COLOR, &cht->back, TRUE, TRUE);
	    PyDict_SetItemString(py_char_attr, "back", py_gdkcolor);
	    
	    PyDict_SetItemString(py_char_attr, "underline", 
		    PyInt_FromLong(cht->underline));
	    PyDict_SetItemString(py_char_attr, "strikethrough", 
		    PyInt_FromLong(cht->strikethrough));

	    PyTuple_SetItem(py_attrs, count, py_char_attr);
	}
	g_array_free(attrs, TRUE);
	return Py_BuildValue("(OO)", text, py_attrs);
    } else {
    	return Py_BuildValue("O", text);
    }
}
%%
override vte_terminal_set_colors kwargs
static PyObject *
_wrap_vte_terminal_set_colors(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "foreground", "background", "palette", NULL };
    PyObject *py_foreground, *py_background, *py_palette, *item;
    int palette_size, i;
    GdkColor *foreground = NULL, *background = NULL, *palette = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:VteTerminal.set_colors", kwlist, &py_foreground, &py_background, &py_palette, &palette_size))
        return NULL;
    if (pyg_boxed_check(py_foreground, GDK_TYPE_COLOR))
        foreground = pyg_boxed_get(py_foreground, GdkColor);
    else {
        PyErr_SetString(PyExc_TypeError, "foreground should be a GdkColor");
        return NULL;
    }
    if (pyg_boxed_check(py_background, GDK_TYPE_COLOR))
        background = pyg_boxed_get(py_background, GdkColor);
    else {
        PyErr_SetString(PyExc_TypeError, "background should be a GdkColor");
        return NULL;
    }
    if (PySequence_Check(py_palette)) {
	palette_size = PySequence_Length(py_palette);
        palette = g_malloc(sizeof(GdkColor) * palette_size);
	for (i = 0; i < palette_size; i++) {
	    item = PySequence_GetItem(py_palette, i);
            if (!pyg_boxed_check(item, GDK_TYPE_COLOR)) {
		g_free(palette);
        	PyErr_SetString(PyExc_TypeError, "palette should be a list of GdkColors");
		return NULL;
	    }
	    palette[i] = *((GdkColor*)pyg_boxed_get(py_palette, GdkColor));
            Py_DECREF(item);
	}
    } else {
        PyErr_SetString(PyExc_TypeError, "palette should be a list of GdkColors");
        return NULL;
    }
    vte_terminal_set_colors(VTE_TERMINAL(self->obj), foreground, background, palette, palette_size);
    g_free(palette);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
