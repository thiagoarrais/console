/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#include <Python.h>
#include <pygtk/pygtk.h>
#include <gtk/gtk.h>
#include "../src/vte.h"
%%
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import gtk.MenuShell as PyGtkMenuShell_Type
import gtk.Widget as PyGtkWidget_Type
%%
ignore vte_terminal_get_text
ignore vte_terminal_get_text_range
%%
override vte_terminal_fork_command kwargs
static PyObject *
_wrap_vte_terminal_fork_command(PyGObject * self, PyObject * args,
				PyObject * kwargs)
{
	gchar **argv = NULL, **envv = NULL;
	gchar *command = NULL;
	static char *kwlist[] = { "command", "argv", "envv", NULL };
	PyObject *py_argv = NULL, *py_envv = NULL;
	int i, n_args, n_envs;
	pid_t pid;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|sOO:fork_command",
					 kwlist, &command, &py_argv,
					 &py_envv)) {
		return NULL;
	}


	if (py_argv != NULL && py_argv != Py_None) {
		if (!PySequence_Check(py_argv)) {
			PyErr_SetString(PyExc_TypeError,
					"argv must be a sequence");
			return NULL;
		}

		n_args = PySequence_Length(py_argv);
		argv = g_new(gchar *, n_args + 1);
		for (i = 0; i < n_args; i++) {
			PyObject *item = PySequence_GetItem(py_argv, i);
			Py_DECREF(item);  /* PySequence_GetItem INCREF's */
			argv[i] = PyString_AsString(item);
		}
		argv[n_args] = NULL;
	}

	if (py_envv != NULL && py_envv != Py_None) {
		if (!PySequence_Check(py_envv)) {
			PyErr_SetString(PyExc_TypeError,
					"envv must be a sequence");
			return NULL;
		}

		n_envs = PySequence_Length(py_envv);
		envv = g_new(gchar *, n_envs + 1);
		for (i = 0; i < n_envs; i++) {
			PyObject *item = PySequence_GetItem(py_envv, i);
			Py_DECREF(item);  /* PySequence_GetItem INCREF's */
			envv[i] = PyString_AsString(item);
		}
		envv[n_envs] = NULL;
	}

	pid = vte_terminal_fork_command(VTE_TERMINAL(self->obj),
					command, argv, envv);

	if (argv) {
		g_free(argv);
	}

	return PyInt_FromLong(pid);
}
%%
